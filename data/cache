Hereâ€™s how you can structure your hexagonal architecture (ports and adapters) for the Kafka consumer:

1. Module Breakdown
Infrastructure Layer (Adapters)

Kafka Adapter: Listens to Kafka topic ABC, deserializes the Proto message, and passes it to the application service.
Persistence Adapter: Handles Oracle DB interactions for data enrichment.
Cache Adapter: Uses Caffeine for in-memory caching.
Application Layer (Service)

TaxProcessingService: Orchestrates message processing, calling the EnrichmentService before sending enriched TaxEntity for further processing.
Domain Layer (Core Business Logic)

TaxEntity: Core business entity.
EnrichmentService (Port): Interface for enriching TaxEntity (implemented by cache and DB adapter).
2. Code Structure
css
Copy
Edit
src/main/java/com/example/taxprocessing
â”‚â”€â”€ application
â”‚   â”œâ”€â”€ service
â”‚   â”‚   â”œâ”€â”€ TaxProcessingService.java
â”‚   â”‚   â”œâ”€â”€ EnrichmentService.java (Port)
â”‚â”€â”€ domain
â”‚   â”œâ”€â”€ model
â”‚   â”‚   â”œâ”€â”€ TaxEntity.java
â”‚â”€â”€ infrastructure
â”‚   â”œâ”€â”€ kafka
â”‚   â”‚   â”œâ”€â”€ KafkaTaxConsumer.java
â”‚   â”œâ”€â”€ persistence
â”‚   â”‚   â”œâ”€â”€ OracleTaxRepository.java (Adapter)
â”‚   â”œâ”€â”€ cache
â”‚   â”‚   â”œâ”€â”€ CaffeineCacheAdapter.java (Adapter)
â”‚â”€â”€ config
â”‚   â”œâ”€â”€ KafkaConfig.java
â”‚   â”œâ”€â”€ CacheConfig.java
â”‚â”€â”€ main
â”‚   â”œâ”€â”€ TaxApplication.java
3. Implementation Details
3.1 Kafka Adapter (Inbound Adapter)
java
Copy
Edit
@Component
@KafkaListener(topics = "ABC", groupId = "tax-group")
public class KafkaTaxConsumer {

    private final TaxProcessingService taxProcessingService;

    public KafkaTaxConsumer(TaxProcessingService taxProcessingService) {
        this.taxProcessingService = taxProcessingService;
    }

    @KafkaHandler
    public void consume(TaxProtoMessage protoMessage) {
        TaxEntity taxEntity = TaxProtoConverter.convert(protoMessage);
        taxProcessingService.processTaxEntity(taxEntity);
    }
}
3.2 TaxProcessingService (Application Service)
java
Copy
Edit
@Service
public class TaxProcessingService {

    private final EnrichmentService enrichmentService;

    public TaxProcessingService(EnrichmentService enrichmentService) {
        this.enrichmentService = enrichmentService;
    }

    public void processTaxEntity(TaxEntity taxEntity) {
        enrichmentService.enrich(taxEntity);
        // Further processing
    }
}
3.3 EnrichmentService (Port)
java
Copy
Edit
public interface EnrichmentService {
    void enrich(TaxEntity taxEntity);
}
3.4 Caffeine Cache Adapter (Implementation of Port)
java
Copy
Edit
@Component
public class CaffeineCacheAdapter implements EnrichmentService {

    private final OracleTaxRepository taxRepository;
    private final Cache<String, TaxEntity> cache;

    public CaffeineCacheAdapter(OracleTaxRepository taxRepository, Cache<String, TaxEntity> cache) {
        this.taxRepository = taxRepository;
        this.cache = cache;
    }

    @Override
    public void enrich(TaxEntity taxEntity) {
        TaxEntity cachedData = cache.getIfPresent(taxEntity.getId());
        if (cachedData == null) {
            cachedData = taxRepository.findById(taxEntity.getId());
            cache.put(taxEntity.getId(), cachedData);
        }
        taxEntity.merge(cachedData);
    }
}
3.5 Oracle DB Adapter (Persistence)
java
Copy
Edit
@Repository
public class OracleTaxRepository {

    private final JdbcTemplate jdbcTemplate;

    public OracleTaxRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    public TaxEntity findById(String id) {
        // Fetch from Oracle DB
    }
}
3.6 Configurations
java
Copy
Edit
@Configuration
public class CacheConfig {
    @Bean
    public Cache<String, TaxEntity> caffeineCache() {
        return Caffeine.newBuilder()
                .maximumSize(1000)
                .expireAfterWrite(Duration.ofMinutes(10))
                .build();
    }
}
4. Key Benefits of This Structure
Kafka Adapter decoupled from application logic.
Hexagonal Ports & Adapters ensure testability.
Cache reduces DB calls, ensuring low latency.
Application Service orchestrates logic, keeping concerns separate.
This approach ensures scalability while keeping your system modular and maintainable. ðŸš€



To test the components in your hexagonal architecture effectively, you should use JUnit 5, Mockito, and H2 (for database tests). Here's how you can structure the tests for each layer.

1. Testing the Kafka Consumer (Inbound Adapter)
Since Kafka is external, we mock its behavior using Mockito.

Test Setup for KafkaTaxConsumer
java
Copy
Edit
@ExtendWith(MockitoExtension.class)
class KafkaTaxConsumerTest {

    @InjectMocks
    private KafkaTaxConsumer kafkaTaxConsumer;

    @Mock
    private TaxProcessingService taxProcessingService;

    @Test
    void shouldProcessMessage_whenReceivedFromKafka() {
        // Given
        TaxProtoMessage protoMessage = TaxProtoMessage.newBuilder().setId("123").build();
        TaxEntity taxEntity = new TaxEntity("123");

        // When
        kafkaTaxConsumer.consume(protoMessage);

        // Then
        verify(taxProcessingService, times(1)).processTaxEntity(any(TaxEntity.class));
    }
}
âœ… Mocks TaxProcessingService to avoid calling real implementations.
âœ… Verifies that the service was called once with any TaxEntity.

2. Testing the Application Service (TaxProcessingService)
Here, we mock the EnrichmentService since it's an external dependency.

Test Setup for TaxProcessingService
java
Copy
Edit
@ExtendWith(MockitoExtension.class)
class TaxProcessingServiceTest {

    @InjectMocks
    private TaxProcessingService taxProcessingService;

    @Mock
    private EnrichmentService enrichmentService;

    @Test
    void shouldCallEnrichmentService_whenProcessingTaxEntity() {
        // Given
        TaxEntity taxEntity = new TaxEntity("123");

        // When
        taxProcessingService.processTaxEntity(taxEntity);

        // Then
        verify(enrichmentService, times(1)).enrich(taxEntity);
    }
}
âœ… Mocks EnrichmentService to isolate business logic.
âœ… Verifies that enrich() was called exactly once.

3. Testing the Cache Adapter (CaffeineCacheAdapter)
We mock the Oracle DB repository to prevent actual database calls.

Test Setup for CaffeineCacheAdapter
java
Copy
Edit
@ExtendWith(MockitoExtension.class)
class CaffeineCacheAdapterTest {

    @InjectMocks
    private CaffeineCacheAdapter cacheAdapter;

    @Mock
    private OracleTaxRepository taxRepository;

    @Mock
    private Cache<String, TaxEntity> cache;

    @Test
    void shouldFetchFromCacheBeforeDB() {
        // Given
        TaxEntity cachedEntity = new TaxEntity("123");
        when(cache.getIfPresent("123")).thenReturn(cachedEntity);

        TaxEntity taxEntity = new TaxEntity("123");

        // When
        cacheAdapter.enrich(taxEntity);

        // Then
        verify(taxRepository, never()).findById(anyString()); // DB should not be called
        verify(cache, times(1)).getIfPresent("123");
    }

    @Test
    void shouldFetchFromDBIfCacheMisses() {
        // Given
        TaxEntity dbEntity = new TaxEntity("123");
        when(cache.getIfPresent("123")).thenReturn(null);
        when(taxRepository.findById("123")).thenReturn(dbEntity);

        TaxEntity taxEntity = new TaxEntity("123");

        // When
        cacheAdapter.enrich(taxEntity);

        // Then
        verify(taxRepository, times(1)).findById("123");
        verify(cache, times(1)).put("123", dbEntity);
    }
}
âœ… Tests both cache hit and cache miss scenarios.
âœ… Ensures DB is only called when necessary.

4. Testing Oracle DB Adapter (OracleTaxRepository) with H2
For database testing, we use H2 in-memory database.

Test Setup for OracleTaxRepository
java
Copy
Edit
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Import(OracleTaxRepository.class)
class OracleTaxRepositoryTest {

    @Autowired
    private OracleTaxRepository taxRepository;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @BeforeEach
    void setup() {
        jdbcTemplate.execute("INSERT INTO tax_entity (id, name) VALUES ('123', 'TestTax')");
    }

    @Test
    void shouldFetchDataFromDatabase() {
        // When
        TaxEntity entity = taxRepository.findById("123");

        // Then
        assertNotNull(entity);
        assertEquals("123", entity.getId());
        assertEquals("TestTax", entity.getName());
    }
}
âœ… Uses H2 for an in-memory database environment.
âœ… Verifies that data is correctly fetched from DB.

5. Integration Testing the Kafka Flow
We use Testcontainers to spin up an actual Kafka broker for integration testing.

Test Setup for Kafka Integration
java
Copy
Edit
@Testcontainers
@SpringBootTest
class KafkaIntegrationTest {

    @Container
    public static KafkaContainer kafka = new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:latest"));

    @Autowired
    private KafkaTemplate<String, TaxProtoMessage> kafkaTemplate;

    @Autowired
    private TaxProcessingService taxProcessingService;

    @DynamicPropertySource
    static void kafkaProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.kafka.bootstrap-servers", kafka::getBootstrapServers);
    }

    @Test
    void shouldConsumeAndProcessMessage() {
        // Given
        TaxProtoMessage message = TaxProtoMessage.newBuilder().setId("123").build();

        // When
        kafkaTemplate.send("ABC", message);

        // Then
        await().atMost(5, TimeUnit.SECONDS).untilAsserted(() -> {
            verify(taxProcessingService, times(1)).processTaxEntity(any(TaxEntity.class));
        });
    }
}
âœ… Uses Testcontainers to run a real Kafka instance.
âœ… Verifies end-to-end message flow.

6. Running Tests in CI/CD
Unit tests run with JUnit + Mockito.
H2 DB tests run without needing a real Oracle DB.
Kafka integration tests use Testcontainers.
CI/CD Pipeline should:
Run mvn test for unit tests.
Use Docker/Testcontainers for Kafka tests.
H2 ensures DB independence.
Final Thoughts
Unit Tests: Ensure individual components work.
Mocking: Prevents unnecessary dependencies.
H2 & Testcontainers: Enable realistic but isolated testing.
CI/CD Friendly: Works in pipelines with minimal external dependencies.



